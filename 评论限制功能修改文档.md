# 评论限制功能修改文档

## 功能需求变更

将评论限制从基于用户账号改为基于昵称：
- **原需求**：同个账号（用户ID）在一个链接里面，只能发两篇评论，而且这两篇评论内容不能完全一样
- **新需求**：同个昵称在一个链接里面，只能发两篇评论，而且这两篇评论内容不能完全一样

## 修改方案

### 1. 核心逻辑变更

将限制维度从用户账号ID改为昵称，具体修改如下：

```javascript
// 原代码：基于用户账号的检查
const existingComments = await ImageReview.find({
  userId: req.user._id,  // 修正：实际字段名是userId
  imageType: 'comment',
  noteUrl: noteUrl.trim(),
  status: { $in: ['manager_approved', 'completed'] }
});

// 新代码：基于昵称的检查
const existingComments = await ImageReview.find({
  'aiParsedNoteInfo.author': authorToCheck,  // 使用昵称而不是用户ID
  imageType: 'comment',
  noteUrl: noteUrl.trim(),
  status: { $in: ['manager_approved', 'completed'] }
});
```

### 2. 添加昵称获取逻辑

由于现在基于昵称，需要添加以下代码来获取昵称信息：

```javascript
// 获取昵称信息：优先使用用户提交的noteAuthor
let authorToCheck = null;
if (Array.isArray(noteAuthor) && noteAuthor.length > 0) {
  authorToCheck = noteAuthor[0].trim(); // 取第一个昵称
} else if (typeof noteAuthor === 'string' && noteAuthor.trim()) {
  authorToCheck = noteAuthor.trim();
}

// 如果用户没提供昵称，尝试从评论验证结果中获取
if (!authorToCheck && aiReviewResult.commentVerification?.foundComments?.length > 0) {
  authorToCheck = aiReviewResult.commentVerification.foundComments[0].author;
}

if (authorToCheck) {
  // ... 检查逻辑
}
```

### 3. 简化验证逻辑

新的验证逻辑基于昵称检查：

```javascript
// 在AI审核通过后，检查昵称+链接限制
if (aiReviewResult && aiReviewResult.aiReview && aiReviewResult.aiReview.passed && aiReviewResult.aiReview.confidence >= 0.9) {
  console.log('🎉 AI审核通过，开始检查昵称+链接评论限制...');

  // 获取昵称信息：优先使用用户提交的noteAuthor
  let authorToCheck = null;
  if (Array.isArray(noteAuthor) && noteAuthor.length > 0) {
    authorToCheck = noteAuthor[0].trim(); // 取第一个昵称
  } else if (typeof noteAuthor === 'string' && noteAuthor.trim()) {
    authorToCheck = noteAuthor.trim();
  }

  // 如果用户没提供昵称，尝试从评论验证结果中获取
  if (!authorToCheck && aiReviewResult.commentVerification?.foundComments?.length > 0) {
    authorToCheck = aiReviewResult.commentVerification.foundComments[0].author;
  }

  if (authorToCheck) {
    // 检查该昵称在该链接下已经有多少条评论
    const existingComments = await ImageReview.find({
      'aiParsedNoteInfo.author': authorToCheck,
      imageType: 'comment',
      noteUrl: noteUrl.trim(),
      status: { $in: ['manager_approved', 'completed'] }
    });

    console.log(`昵称评论限制检查 - 昵称:"${authorToCheck}", 链接:${noteUrl}, 现有评论数:${existingComments.length}`);

    if (existingComments.length >= 2) {
      console.log(`❌ 昵称评论限制触发：昵称"${authorToCheck}"在该链接下已有${existingComments.length}条评论`);
  
      // 拒绝审核通过
      reviewData.status = 'manager_rejected';
      reviewData.rejectionReason = `昵称"${authorToCheck}"在该链接下最多只能发布2条评论`;
  
      // 添加拒绝历史
      reviewData.auditHistory.push({
        operator: null, // AI审核
        operatorName: 'AI审核系统',
        action: 'manager_reject',
        comment: `AI自动审核拒绝：${reviewData.rejectionReason}`,
        timestamp: new Date()
      });
  
      console.log(`❌ 昵称评论限制触发：昵称"${authorToCheck}"在链接${noteUrl}下已有${existingComments.length}条评论`);
  
      // 跳过后续处理
      const review = await new ImageReview(reviewData).save();
      return review;
    }
  
    // 如果已有评论，检查内容是否重复
    if (existingComments.length > 0) {
      const hasDuplicateContent = existingComments.some(review => {
        return review.userNoteInfo &&
               review.userNoteInfo.comment &&
               review.userNoteInfo.comment.trim() === commentContent.trim();
      });
  
      if (hasDuplicateContent) {
        console.log(`❌ 评论内容重复：昵称"${authorToCheck}"在该链接下的评论内容重复`);
  
        // 拒绝审核通过
        reviewData.status = 'manager_rejected';
        reviewData.rejectionReason = `评论内容不能与该链接下的其他评论完全相同`;
  
        // 添加拒绝历史
        reviewData.auditHistory.push({
          operator: null, // AI审核
          operatorName: 'AI审核系统',
          action: 'manager_reject',
          comment: `AI自动审核拒绝：${reviewData.rejectionReason}`,
          timestamp: new Date()
        });
  
        console.log(`❌ 评论内容重复限制触发：昵称"${authorToCheck}"的内容重复`);
  
        // 跳过后续处理
        const review = await new ImageReview(reviewData).save();
        return review;
      }
    }
  }

  // ... 其余AI审核通过的处理逻辑
}
```

### 4. 数据库索引优化

更新数据库索引以适应新的查询模式：

```javascript
// 在 ImageReview 模型中更新索引（用于昵称评论限制查询）
imageReviewSchema.index({ 'aiParsedNoteInfo.author': 1, imageType: 1, noteUrl: 1, status: 1 });
```

### 5. 错误信息更新

更新拒绝原因信息：
- 原：`每个账号在该链接下最多只能发布2条评论`
- 新：`昵称"${authorToCheck}"在该链接下最多只能发布2条评论`

## 实现位置

### 文件修改
1. `server/routes/client.js` - 在 `/tasks/batch-submit` 端点中修改验证逻辑
2. `server/models/ImageReview.js` - 更新数据库索引

### 具体修改点
在 `server/routes/client.js` 第824行之后，AI审核通过的处理逻辑中，将用户账号限制检查改为昵称限制检查。

## 测试用例

### 正常情况
- 昵称A首次在链接A发评论：允许
- 昵称A第二次在链接A发评论：允许
- 昵称A第三次在链接A发评论：拒绝

### 异常情况
- 昵称A在链接A发两篇相同评论：第二篇拒绝（内容重复）
- 昵称A在不同链接发相同评论：允许
- 不同昵称在同一链接发评论：各自独立计算
- 同一用户用不同昵称在同一链接发评论：各自独立计算（因为基于昵称）

## 优势

相比用户账号限制，昵称限制有以下优势：
1. **更灵活的控制**：允许用户通过更换昵称在同一链接发布更多评论
2. **更简单的逻辑**：直接基于昵称字符串匹配，不依赖用户身份验证
3. **更好的用户体验**：用户可以通过更换昵称绕过账号级别的限制

## 劣势

相比用户账号限制，昵称限制有以下劣势：
1. **更弱的控制**：用户可以通过更换昵称轻易绕过限制
2. **依赖昵称准确性**：限制效果依赖于昵称的正确获取和匹配
3. **潜在的滥用**：用户可以创建多个昵称来发布更多评论

## 兼容性考虑

- 现有数据：不会影响已有的评论记录
- 迁移：无需数据迁移，新逻辑直接生效
- 回滚：如果需要回滚到用户账号限制，可以恢复原有代码